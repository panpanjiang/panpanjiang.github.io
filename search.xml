<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二维坐标系间的转换]]></title>
    <url>%2F2018%2F12%2F14%2FOriented-Fast%2F</url>
    <content type="text"><![CDATA[描述在ORB特征点计算描述时，在计算之前需要将要比较的点对p,q根据Fast里计算出的方向$\theta$，先转一下得到$p^{‘},q^{‘}$，再比较$p^{‘},q^{‘}​$。那么这个转换如何计算呢？ 问题在坐标系uov中有点p,op绕o旋转$\theta$，求旋转后的点$p^{‘}$在坐标系uvo中的坐标。 分析解答 在求解的时候注意旋转角$\theta$的正负、坐标轴的朝向等问题。]]></content>
      <categories>
        <category>图像基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图像去畸变]]></title>
    <url>%2F2018%2F12%2F07%2Fundistorted%2F</url>
    <content type="text"><![CDATA[现实生活中的图像总存在畸变。原则上来说,针孔透视相机应该将三维世界中的直线投影成直线,但是当我们使用广角和鱼眼镜头时,由于畸变的原因,直线在图像里看起来是扭曲的。如下图所示： 可以明显看到实际的柱子、箱子的直线边缘在图像中被扭曲成了曲线。这就是由相机畸变造成的。在这里，我们只考虑径向畸变和切向畸变，畸变模型是叠加在归一化平面（投影模型）上的。径向切向畸变公式合起来写如下： x_{distorted}=x(1+k_1r^2+k_2r^4)+2p_1xy+p_2(r^2+2x^2) \\ y_{distorted}=y(1+k_1r^2+k_2r^4)+p_1(r^2+2y^2)+2p_2xy其中， $x_{distorted},y_{distorted}$表示畸变后的投影模型上的坐标 $x,y$表示畸变前的投影模型上的坐标 $r^2=x^2+y^2$ 去畸变思路：构建一个空白的图像（去畸变后的图像），然后遍历空白图像的每个像素点，通过像素点$\rightarrow$归一化平面坐标$\rightarrow$畸变模型$\rightarrow$畸变图像上的像素坐标，从而得到了去畸变后的图像与畸变图像像素坐标之间对应关系，由此问题得解。 ++123456789101112131415161718192021// 计算去畸变后图像的内容 for (int v = 0; v &lt; rows; v++) for (int u = 0; u &lt; cols; u++) &#123; double u_distorted = 0, v_distorted = 0; //按照公式，计算点(u,v)对应到畸变图像中的坐标(u_distorted, v_distorted) double x=(u-cx)/fx; double y=(v-cy)/fy;//归一化坐标 double r2=x*x+y*y; double x_distorted=x*(1+k1*r2+k2*r2*r2)+2*p1*x*y+p2*(r2+2*x*x); double y_distorted=y*(1+k1*r2+k2*r2*r2)+p1*(r2+2*y*y)+2*p2*x*y; u_distorted=x_distorted*fx+cx; v_distorted=y_distorted*fy+cy; // 赋值 (最近邻插值) if (u_distorted &gt;= 0 &amp;&amp; v_distorted &gt;= 0 &amp;&amp; u_distorted &lt; cols &amp;&amp; v_distorted &lt; rows) &#123; image_undistort.at&lt;uchar&gt;(v, u) = image.at&lt;uchar&gt;((int) v_distorted, (int) u_distorted); &#125; else &#123; image_undistort.at&lt;uchar&gt;(v, u) = 0; &#125; &#125; 可以看到去畸变后，箱子和柱子边缘的线明显变直了：]]></content>
      <categories>
        <category>图像基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shi-Tomasi score]]></title>
    <url>%2F2018%2F12%2F07%2Fharris-shitomasi%2F</url>
    <content type="text"><![CDATA[在视觉里程计部分，在对图像帧提取Fast特征点后，计算shi-Tomasi角点检测，根据阈值选择更好的角点。 那什么是shi-Tomasi角点检测？shi-Tomasi分数又该如何计算呢？shi-Tomasi是harris角点的改进版。我们先来看看harris角点检测。 harris 角点检测harris的想法是，在image里，如果一个小的patch（或者叫窗口）进行小范围的移动时，窗口内的像素灰度值能产生明显的变化，则认为该窗口中存在角点。转换成数学表达式为： E(u,v)=\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2 $E$是原始窗口和移动后的窗口的差分 $u$是在$x$方向上窗口的平移 $v$是在$y$方向上窗口的平移 $w(x,y)$是窗口在点$(x,y)$位置上的权重 $I$是图像在点$(x,y)$处的灰度值 $I(x+u,y+v)$指窗口移动后的灰度值 $I(x,y)$指原始窗口的灰度值 现在若要找到一个harris角点，则需要寻找一个窗口，使得其能产生一个大的$E$。也就是要最大化下面的式子(这里先把权重放一边，后面再补上)： E(u,v)=\sum_{x,y}[I(x+u,y+v)-I(x,y)]^2对上式进行一阶泰勒展开得： E(u,v)\approx \sum_{x,y}[I(x,y)+uI_x+vI_y-I(x,y)]^2 \\ =\sum_{x,y} (u^2I_x^2+2uvI_xI_y+v^2I_y^2) \\ =\left[\begin{matrix} u & v \end{matrix}\right](\sum \left[\begin{matrix} I_x^2 & I_xI_y \\ I_xI_y & I_y^2 \end{matrix}\right])\left[\begin{matrix} u\\ v\end{matrix}\right]在这里把刚才我们丢掉的权重补上，令 M=\sum w(x,y)\left[\begin{matrix} I_x^2 & I_xI_y \\ I_xI_y & I_y^2 \end{matrix}\right]所以， E(u,v)\approx \left[\begin{matrix} u&v\end{matrix}\right]M\left[\begin{matrix}u\\v\end{matrix}\right]$M$的特征值$\lambda_1,\lambda_2$有助于判断一个窗口是否含有角点： 若两个特征值都小，则在各个方向上都没有变化，说明窗口处在平滑区域 若其中一个特征值大，另一个小，说明窗口在边缘上，沿边缘方向移动没有变化 若两个特征值都大，则窗口中存在角点 至此，我们就可以计算harris的评分分数$R$，若分数$R$大于某一阈值，则认为该窗口中存在角点： R=detM-k(traceM)^2 \\ detM=\lambda_1\lambda_2\\ traceM=\lambda_1+\lambda_2shi-Tomasi角点检测shi-Tomasi角点检测是在harris上稍作修改，修改了评分计算： R=min(\lambda_1,\lambda_2)在视觉里程计中，该部分的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142float FastDetector::shiTomasiScore(const cv::Mat&amp; img, int u, int v) &#123; assert(img.type() == CV_8UC1); float dXX = 0.0; float dYY = 0.0; float dXY = 0.0; const int halfbox_size = 4; const int box_size = 2 * halfbox_size; const int box_area = box_size*box_size; const int x_min = u - halfbox_size; const int x_max = u + halfbox_size; const int y_min = v - halfbox_size; const int y_max = v + halfbox_size; if (x_min &lt; 1 || x_max &gt;= img.cols - 1 || y_min &lt; 1 || y_max &gt;= img.rows - 1) return 0.0; // 面片太靠近边界，返回0 const int stride = img.step.p[0];//一行元素的个数 for (int y = y_min; y &lt; y_max; ++y)//垂直平移,计算每次平移后对角线上的灰度值差 &#123; const uint8_t* ptr_left = img.data + stride*y + x_min - 1; const uint8_t* ptr_right = img.data + stride*y + x_min + 1; const uint8_t* ptr_top = img.data + stride*(y - 1) + x_min; const uint8_t* ptr_bottom = img.data + stride*(y + 1) + x_min; for (int x = 0; x &lt; box_size; ++x, ++ptr_left, ++ptr_right, ++ptr_top, ++ptr_bottom) &#123; float dx = *ptr_right - *ptr_left;//计算I在x处的导数 float dy = *ptr_bottom - *ptr_top;//计算I在y处的导数 dXX += dx*dx; dYY += dy*dy; dXY += dx*dy; &#125; &#125; // 返回小的特征值 dXX = dXX / (2.0 * box_area);//应该是乘了w(x,y)，权重 dYY = dYY / (2.0 * box_area); dXY = dXY / (2.0 * box_area); //解一元二次方程，求最小特征值 return 0.5 * (dXX + dYY - sqrt((dXX + dYY) * (dXX + dYY) - 4 * (dXX * dYY - dXY * dXY))); &#125;]]></content>
      <categories>
        <category>图像基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单的两两帧单目视觉里程计]]></title>
    <url>%2F2018%2F11%2F16%2Flearn-vo-1%2F</url>
    <content type="text"><![CDATA[这是一个简单的两两帧视觉里程计，两帧图像之间R，t的估计只使用了对极几何，尺度因子由数据集的真实轨迹获得，本项目的实现基于Opencv. 问题描述：输入：使用相机采集的图片序列；相机的内参（即焦距$f_x$,$fy$,相机光心$c_x$,$c_y$,畸变参数$k_1$,$k_2$,$k_3$,$p_1$,$p_2$），相机内参可通过Opencv、matlab、kalibr等工具进行标定。 输出：以第一帧图片为参考系，输出每帧图片的坐标。 算法步骤： 读入相机参数 获取两帧连续图像$I^t$,$I^{t+1}$ 对获取的图像进行去畸变处理 对$I^t$提取FAST特征点，使用LK金字塔光流法在$I^{t+1}$中跟踪这些特征点，若跟踪的特征点数量小于预设的阈值，则在$I^{t+1}$中重新提取FAST特征点 使用五点法及RANSAC计算本质矩阵$E$ 通过本质矩阵$E$估计两帧之间的$R,t$ 使用数据集中的真实轨迹获取两帧之间的尺度因子，计算出$I^{t+1}$在参考系中的$R,t$并输出显示 核心算法代码： 从第二帧开始，通过真实轨迹坐标计算并保存每帧的尺度到vector中 12345678910111213141516171819void getAbusoluteScale(vector&lt;double&gt; scale,string ground_truth)&#123; ifstream in; in.open(ground_truth); scale.push_back(1); string line=""; getline(in,line); istringstream item(line); double x_pre=0,y_pre=0,z_pre=0; double x=0,y=0,z=0; item&gt;&gt;x_pre&gt;&gt;y_pre&gt;&gt;z_pre; while(getline(in,line))&#123; istringstream nextItem(line); nextItem&gt;&gt;x&gt;&gt;y&gt;&gt;z; scale.push_back(sqrt((x - x_pre)*(x - x_pre) + (y - y_pre)*(y - y_pre) + (z - z_pre)*(z - z_pre))); x_pre=x; y_pre=y; z_pre=z; &#125;&#125; 转灰度图、去畸变 12cvtColor(ref,ref,CV_BGR2GRAY);undistort(ref,ref,K,DistCoef); 获取FAST特征点，并将其存于类型为vector的kp中，便于后续LK跟踪、本质矩阵计算 12345void featureDetection(Mat&amp; frame,vector&lt;Point2f&gt;&amp; kp)&#123; vector&lt;Point2f&gt; keypoints; FAST(frame,keypoints,40,true); KeyPoint::convert(keypoints,kp);&#125; 使用opencv的函数进行光流跟踪，返回两幅图像的匹配点，并将跟踪失败的点去掉 12345678910111213141516void LKFeatureTracking(Mat&amp; ref,Mat&amp; curr,vector&lt;Point2f&gt;&amp; ref_kp,vector&lt;Point2f&gt;&amp; cur_kp)&#123; vector&lt;uchar&gt; status; vector&lt;float&gt; err; cvCalcOpticalFlowPyrLK(ref,curr,ref_kp,cur_kp,status,err); vector&lt;Point2f&gt;::iterator ref_iter=ref_kp.begin(); vector&lt;Point2f&gt;::iterator cur_iter=cur_kp.begin(); for(auto state:status)&#123; if(state==0)&#123; ref_kp.erase(ref_iter); cur_kp.erase(cur_iter); &#125;else&#123; ref_iter++; cur_iter++; &#125; &#125; &#125; 计算本质矩阵，并从本质矩阵中估计R，t 12E=findEssentialMat(cur_kp,ref_kp,K,RANSAC);recoverPose(E, cur_kp,ref_kp,K,R, t); 设有三帧图像,索引分别为1,2,3，其中， T_{12}=\left[\begin{matrix} R_{12} & t_{12}\\ 0^T & 1 \end{matrix}\right] T_{23}=\left[\begin{matrix} R_{23} & t_{23}\\ 0^T & 1 \end{matrix}\right]\\所以第三帧到第一帧的变换矩阵为： T_{13}=T_{12}T_{23}=\left[\begin{matrix} R_{12}R_{23} & R_{12}t_{23}+t_{12}\\ 0^T & 1 \end{matrix}\right]所以，获取各帧图像的pose代码如下： 12t_f=R_f*(scale[frame_id]*t)+t_f;R_f=R_f*R; 如果需要跟踪的特征点少于阈值，则重新提取特征点 123if(cur_kp.size()&lt;MIN_NUM)&#123; featureDetection(curr,cur_kp);&#125; 数据集KITTI，运行结果： 与真实轨迹比较： 参考资料：http://avisingh599.github.io/vision/monocular-vo/]]></content>
      <categories>
        <category>Visual Odometry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode_tips]]></title>
    <url>%2F2018%2F11%2F09%2Fleetcode-tips%2F</url>
    <content type="text"><![CDATA[寻找一棵Tree的每层中的一个特殊值时，两种方法：广度搜索、深度搜索。 广度搜索模板： 1234567891011121314queue&lt;int&gt; que;que.push(root);while(que.size()&gt;0)&#123; int num=que.size();//当前que中只存储了一层的节点 for(int i=0;i&lt;num;i++)&#123;//一次将一层中的节点遍历 TreeNode* cur_row=que.front(); que.pop(); //do something to get the value of this level here if(root-&gt;left!=NULL) que.push(root-&gt;left); if(root-&gt;right!=NULL) que.push(root-&gt;right); &#125;&#125; 深度搜索模板，例如找每层最右边的节点值： 12345678void dfs(TreeNode* root,int level,vector&lt;int&gt;&amp; result)&#123; if(!root) return; //当前level还没找到最右边的值，将当前值作为该level的最右边值 if(result.size()&lt;level) result.push_back(root-&gt;val); //接着找下一层最右边的值 dfs(root-&gt;right,level+1,result); dfs(root-&gt;left,leve+1,result);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[rovio 详细安装及运行步骤]]></title>
    <url>%2F2018%2F10%2F28%2Frovio%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[rovio 详细安装及运行步骤笔者环境：ubuntu16.04+ROS kinetic 创建工作空间 123$ mkdir -p ~/catkin_vio/src$ cd ~/catkin_vio$ catkin_make 安装依赖 12$ sudo apt-get install freeglut3-dev$ sudo apt-get install libglew-dev 任找一个目录安装kindr 12345$ git clone https://github.com/ANYbotics/kindr.git$ mkdir build$ cd build$ cmake ..$ sudo make install 在新建的catkin_vio/src下： 12$ git clone https://github.com/ethz-asl/rovio.git$ git submodule update --init --recursive 回到catkin_vio下： 12$ catkin_make rovio --cmake-args -DCMAKE_BUILD_TYPE=Release -DMAKE_SCENE=ON$ catkin_make 运行数据集 下载数据集文件如MH_01_easy.bag，在launch文件夹下的rovio_rosbag_node.launch,修改数据文件路径参数 运行： 123$ roscore$ source devel/setup.zsh(or .bash)$ roslaunch rovio rovio_rosbag_node.launch 若发生BagIOException，则在存放数据集的文件夹中手动建一个rovio文件夹，再重新运行即可解决]]></content>
      <categories>
        <category>rovio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[638.Shopping Offers]]></title>
    <url>%2F2018%2F10%2F28%2F638%2F</url>
    <content type="text"><![CDATA[题目详见：https://leetcode.com/problems/shopping-offers/ 思路：递归+回溯。以必须购买的物品及其数量为目标，每次递归时，有两种情况：一为达到目标的最大花费即所有物品按原价购买，将该花费作为上限；二是购买special offers，花费为special offers的price+购买剩余物品的最少花费，此时，要考虑买到的物品是否符合要求，买到的物品数量不得超出目标数。 1234567891011121314151617181920212223242526class Solution &#123;public: int shoppingOffers(vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs) &#123; int minpay=0; for(int i=0;i&lt;needs.size();i++)&#123; minpay+=price[i]*needs[i]; &#125; for(auto s:special)&#123; bool can=true; for(int i=0;i&lt;needs.size();i++)&#123; if(needs[i]&lt;s[i])&#123; can=false; break; &#125; &#125; if(can)&#123; for(int i=0;i&lt;needs.size();i++) needs[i]-=s[i]; minpay=min(minpay,s[needs.size()]+shoppingOffers(price,special,needs)); for(int i=0;i&lt;needs.size();i++) needs[i]+=s[i]; &#125; &#125; return minpay; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[756. Pyramid Transition Matrix]]></title>
    <url>%2F2018%2F10%2F28%2F756%2F</url>
    <content type="text"><![CDATA[题目详见：https://leetcode.com/problems/pyramid-transition-matrix/ 思路：递归，回溯。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool pyramidTransition(string bottom, vector&lt;string&gt;&amp; allowed) &#123; unordered_map&lt;string,vector&lt;char&gt;&gt; allowed_map; for(string element:allowed)&#123; allowed_map[element.substr(0,2)].push_back(element.back()); &#125; string current=""; return DFS(bottom,current,0,allowed_map); &#125;private: //两个字母用一个字母代替 //pre未替换完的字符串 //current当前已替换完得到的字符串 //k,pre开始要替换的字母的index //dict包含可替换的选择 bool DFS(string&amp; pre,string&amp; current,int k,unordered_map&lt;string,vector&lt;char&gt;&gt;&amp; dict)&#123; if(pre.length()==1) return true; if(k+1==pre.length())&#123; string next=""; return DFS(current,next,0,dict); &#125; else&#123; string key=pre.substr(k,2); if(dict.count(key)==0) return false; vector&lt;char&gt; value=dict[key]; for(auto c:value)&#123; current.push_back(c); if(DFS(pre,current,k+1,dict)) return true; current.pop_back(); &#125; return false; &#125; &#125; &#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[851.Loud and Rich]]></title>
    <url>%2F2018%2F10%2F28%2F851%2F</url>
    <content type="text"><![CDATA[题目详见：https://leetcode.com/problems/loud-and-rich/ 思路：广度搜索。 首先初始化answer[i]=i，即为其本身，然后建立一个二维graph，graph[i]存储的是遍历richer得到的比i有钱的人。并在遍历richer的时候给answer[i]赋值为当前遍历得到的符合要求的最小quiet的j。接下来从0开始，依次循环遍历graph，每次循环先将graph[i]中的元素压入临时队列que,然后进行广度搜索，在搜索的同时进行quiet的比较。由于之前在遍历richer的时候已经得到并存储了每组的quiet最小值，所以此时的比较是当前组的quiet值与出队元素组的quiet值的比较，就不用一个一个地比。当graph[0]搜索完成后，得到的answer[0]就是最后的结果，当后续graph[i]进行搜索时，若出队元素为0时，则无需将graph[0]中的元素压入队列，只需与answer[0]比较即可。runtime:48ms,由于queue不支持遍历，set虽然可以去重，但效率比vector低很多，所以graph使用$vector]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[337.House RobberIII]]></title>
    <url>%2F2018%2F10%2F28%2F337%2F</url>
    <content type="text"><![CDATA[题目详见：https://leetcode.com/problems/house-robber-iii/ 思路：深度搜索。两种情况：根节点rob，下一层的子节点必定不会rob；根节点不rob，下一层的左右子节点可rob也可不rob，取max(robLeft,notRobLeft)+max(robRight,notRobRight)作为根节点不rob所得的最大money。 123456789101112131415161718192021222324class Solution &#123;public: int rob(TreeNode* root) &#123; if(!root) return 0; int rob,notRob; dfs(root,rob,notRob); return max(rob,notRob); &#125;private: void dfs(TreeNode* root,int&amp; rob,int&amp; notRob)&#123; if(!root)&#123; rob=0; notRob=0; return; &#125; dfs(root-&gt;left,rob,notRob); int x,y; dfs(root-&gt;right,x,y); int tmp=rob; rob=root-&gt;val+notRob+y; notRob=max(tmp,notRob)+max(x,y); &#125; &#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Rodrigues Formula]]></title>
    <url>%2F2018%2F10%2F28%2FRodrigues%20formula%2F</url>
    <content type="text"><![CDATA[已知旋转向量为$\theta k$，其中$k$为旋转轴上的单位向量，$|k|=1$，$\theta$为绕旋转轴旋转过的角度，证明Rodrigues formula: R=\cos\theta I+(1-\cos\theta)kk^T+\sin\theta k^\times其中，R为对应的旋转矩阵。 设$v$为将被旋转的向量，将其分解为与$k$平行方向及与$k$垂直方向上的两个分量$v_{||}$,$v_{\bot}$。分解如下图所示： 可得： v=v_{||}+v_\bot其中，由投影可知： v_{||}=(v\cdot k)k v_\bot=-k\times(k\times v)将$v$绕$k$轴旋转$\theta$角，即分别将其的两个分量绕$k$轴旋转$\theta$角，旋转后的矢量为： v_{rot}=v_{||rot}+v_{\bot rot} v_{\bot rot}=\cos\theta v_\bot+\sin\theta(k\times v_\bot)由于与$k$轴平行的分量旋转并不发生变化，所以： v_{||rot}=v_{||}其中 k\times v_\bot=k\times (v-v_{||})=k\times v-k\times v_{||}=k\times v所以： v_{rot}=v_{||}+\cos\theta v_\bot+\sin\theta(k\times v)\\ =v-v_\bot+\cos\theta v_\bot+\sin\theta(k\times v)\\ =v+(1-\cos\theta)k\times(k\times v)+\sin\theta(k\times v)\\ =v+(1-\cos\theta)k^\times k^\times v+\sin\theta k^\times v其中$k^\times$为k的反对称矩阵，即 k^\times=\left[ \begin{matrix} 0 & -k_3 & k_2\\ k_3 & 0 & -k_1\\ -k_2 & k_1 &0 \end{matrix} \right]叉积用矩阵表达为: k\times v=k^\times v通过计算可知： I+k^\times k^\times=kk^T代入得： v_{rot}=v+(1-\cos\theta)(kk^T-I)v+\sin\theta k^\times v\\ =\cos\theta Iv+(1-\cos\theta)kk^Tv+\sin\theta k^\times v\\ =(\cos\theta I+(1-\cos\theta)kk^T+\sin\theta k^\times)v又： v_{rot}=Rv所以： R=\cos\theta I+(1-\cos\theta)kk^T+\sin\theta k^\times证毕。]]></content>
      <categories>
        <category>三维空间刚体运动</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[万向锁]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%B8%87%E5%90%91%E9%94%81%2F</url>
    <content type="text"><![CDATA[欧拉角,一种描述三维旋转的方式，即将三维旋转描述分解为3个方向上的旋转。例如：按$Z\rightarrow Y\rightarrow X$的顺序旋转，其中, 绕物体的Z轴旋转，得到偏航角yaw 绕旋转之后的Y轴旋转，得到俯仰角pitch 绕旋转之后的X轴旋转，得到滚转角roll 万向锁，欧拉角中的奇异性问题。即当$pitch=\pm{90^\circ}$时，旋转后的Z轴与原来的X轴重合，此时就会出现：之前先绕X轴旋转$\theta$，再绕Y轴旋转$\pm90^\circ$得到的结果等价于先绕Y轴旋转$\pm90^\circ$，再绕Z轴旋转$\theta$得到的结果，所以描述不唯一，就存在奇异性问题，所以欧拉角一般不做数学运算，多用于人机交互。 理论上可以证明，仅用三个实数表达三维旋转时，不可避免地存在奇异性问题。旋转向量也有奇异性问题，但出现少。 绕Y轴旋转前 绕Y轴旋转后，Z轴与旋转前的X轴重合]]></content>
      <categories>
        <category>三维空间刚体运动</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SO(3)伴随证明]]></title>
    <url>%2F2018%2F10%2F28%2F%E4%BC%B4%E9%9A%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[证明 ：$Rexp(a^\times)R^T=exp((Ra)^\times)$ 解： 将左侧展开得： Rexp(a^\times)R^T=R\sum\frac{(a^\times)^n}{n!}R^T\\ =\sum\frac{R(a^\times)^nR^T}{n!}\\ =\sum\frac{(Ra^\times R^T)(Ra^\times R^T)(Ra^\times R^T)...}{n!}\\ =\sum\frac{(Ra^\times R^T)^n}{n!}\\ =exp(Ra^\times R^T)对要证等式两边同取对数，因此只要证明$Ra^\times R^T=(Ra)^\times$即可。 式子右边同乘向量$v$: (Ra)^\times v=(Ra)\times (RR^Tv)=R(a\times R^Tv)=Ra^\times R^Tv证毕。]]></content>
      <categories>
        <category>李群与李代数</category>
      </categories>
  </entry>
</search>
